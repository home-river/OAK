存放了每日的开发记录

## 2025-11-03

**验证器的实现**

验证器的实现应该先统一调用各个DTO字段内部的验证逻辑，然后再实现各个DTO之间的验证逻辑。所以第一步是重新梳理各个DTO的验证逻辑，并实现验证器的实现。

TODO：
- [ √ ] 重新梳理各个DTO的验证逻辑，并补全内部验证。
- [ √ ] 实现验证器的额外校验逻辑。
- [ √ ] 实现验证器的统一入口。


### 2025-11-04

完善了配置DTO内部的验证逻辑，现在可以对顶层DTO调用验证接口，快速进行DTO内部自检，下一步可以开始实现验证器的额外校验逻辑。
也就是对DTO之间的验证逻辑，比如角色绑定和设备元数据的一致性检查。

### 2025-11-05
完成了验证器的实现。



## 2025-11-05
**配置管理器的实现**

### 2025-11-06
基本完成了样板DTO工具的实现，为配置管理器创建默认配置和配置参数的硬编码管理提供了支持。

**注**：实现样板工具是因为直接管理JSON配置太过于困难，样板工具可以方便的创建默认配置和配置参数的硬编码管理。
后续开发CLI工具或者可视化管理工具后，再迁移重心到JSON配置。

下一步，继续完善配置管理器。



### 2025-11-07

**配置管理器已实现接口**

1. __init__(config_path=None, auto_create=True, eager_load=False, include_runtime_checks=False)
   初始化配置管理器并设置路径/内部状态，可选构造期加载。

2. load_config(validate=True, config_path=None, auto_create=None) -> bool
   从 JSON 读取为 `DeviceManagerConfigDTO`，可自动创建默认配置并做结构校验。

3. save_config() -> bool
   将当前“可运行配置”原子写盘并更新时间戳。

4. get_config() -> DeviceManagerConfigDTO
   获取当前“草稿配置”（未加载则抛错）。

5. get_runnable_config() -> DeviceManagerConfigDTO
   获取当前“可运行配置”（不存在则抛错）。

6. create_and_set_default_config() -> bool
   设备发现→创建默认配置→内部匹配，设置草稿=可运行配置并记录匹配结果。

7. promote_runnable_if_valid(include_runtime_checks=True, persist=False) -> DeviceManagerConfigDTO
   校验草稿通过后晋升为“可运行配置”，可选立即持久化。

8. restore_runnable_config() -> DeviceManagerConfigDTO
   将草稿回滚为最近一次“可运行配置”快照。

9. _match_config_internal(config, online_devices, ..., require_at_least_one_binding=True) -> (DeviceManagerConfigDTO, DeviceMatchResult)
   使用 `DeviceMatchManager` 执行匹配/自动绑定并导出新配置，可选做全量/运行态校验。

10. get_default_config() -> DeviceManagerConfigDTO
   创建并返回的默认配置（工厂方法）：根据设备列表创建未绑定的原生配置，后续需进行绑定


### 2025-11-08

**配置管理器新增已实现接口**

1. get_last_match_result() -> Optional[DeviceMatchResult]
   获取最近一次设备匹配的结果（只读）。

2. is_dirty() -> bool
   检查当前“草稿配置”是否领先于“可运行配置”。

3. has_runnable_config() -> bool
   检查是否存在“可运行配置”。

4. validate_config(include_runtime_checks=False) -> (bool, List[str])
   统一入口执行结构/跨字段校验，可选启用运行态校验。

5. get_oak_module_config() -> OAKModuleConfigDTO
   获取 OAK 模块配置（从“可运行配置”导出）。

6. get_data_processing_config() -> DataProcessingConfigDTO
   获取数据处理模块配置（从“可运行配置”导出）。

7. get_can_config() -> CANConfigDTO
   获取 CAN 模块配置（从“可运行配置”导出）。

8. get_display_config() -> DisplayConfigDTO
   获取显示模块配置（从“可运行配置”导出）。

9. get_system_config() -> SystemConfigDTO
   获取系统模块配置（从“可运行配置”导出）。


## 2025-11-09~2025-11-15

确认了事件模块的实现方案，并实现了事件模块的样板代码。
对各个模块开始增加日志处理功能。
完成了系统异常日志捕捉的钩子函数，线程日志异常捕捉的钩子函数。


## 2025-11-17~2025-11-23
- 11-17
   设备匹配器日志功能补全完毕。
   日志配置从零散配置改为统一入口处进行配置。

- 11-18
   日志统一配置函数`configure_logging`完成。
   `SystemConfigDTO`字段补充了timed rotating file handler的配置字段，支持按时间滚动和按大小滚动两种模式切换

- 11-19
   重新设计了配置管理器相关的日志。

   设计了数据采集模块的接口，并实现了样板代码，等待了解事件模块的具体使用方法后，再进行具体实现。

- 11-20
   事件总线更新了背压管理功能。

   确定了各个模块的主循环使用阻塞队列的形式获取数据，避免循环的空转造成性能开销。

   - 11-21
   事件总线更新了订阅者名称的记录功能。

   数据采集模块实现了采集管线的创建和设备启动。

   关闭了pipeline的NNnetwork输出，避免性能开销，减少传输带宽。

   正在重新设计detectiondto，减少冗余。

   正在设计数据采集模块的采集逻辑，现在在DTO组装阶段。


## 2025-11-24 ~ 2025-11-28

- 11-24

   对detection相关的DTO进行了重构，减少了冗余。具体：
   删除了尺寸信息，删除了detection_id，修改label为int类型。


   对collector模块内的DTO组装逻辑进行优化，减少性能开销。

- 11-25

   对collector中的变量进行修改，去除了self._pipeline变量，使用pipeline_manager.get_pipeline()获取pipeline对象,
   并在self.pipeline_manager中维护pipeline对象，减少复用。

   修复了_assemble_detection_data中的别名获取机制，使用device_binding.role.value获取别名。

   修改了_assemble_detection_data中的边界框坐标获取机制，使用原生坐标（因为本来就是float类型），减少了一步转换。

   去除_assemble_detection_data中多余的类型转换兜底。

   **注** 套用类似于int（）的类型转换作为兜底，会比直接使用多出一步函数调用的成本，在高频loop场景下最好避免。

   修改了PipelineManager中的enable_depth_output的获取机制，使用__resolve_enable_depth_output()获取，避免重复代码。

   为OAK数据流设置了锁结构，添加了安全退出的接口。

   修改了DTO中的enable_depth参数为enable_depth_output，更符合语境。

   实现了stop方法，添加了线程退出的安全检查和join逻辑，提升系统在停止流程时的稳定性。
   实现了start方法，添加了线程启动的安全检查和登记逻辑。
   新增worker_threads字典，维护每个设备的采集线程。

   下一步工作：
   实现显示模块的样板代码，并订阅事件总线，实现检测流+显示的最小闭环。然后做测试。


- 11-26

   修改了collector的running字典和_worker_threads字典的键，额外维护一个role-binding的字典用于查找。

   去除了role-binding字典，因为config内部自带了这个字典。

   修改collector的日志为参数化日志。

   修改数据阻塞获取为非阻塞获取，避免线程阻塞在获取数据上。

   修改帧同步机制，使用硬件序列号作为帧ID。

- 11-27
   事件总线更新了同步/异步模式，并行发布功能。
   并行发布功能使用了线程池，并行执行订阅者回调，提升多核利用率。
   并行发布功能使用了wait_all参数，可以等待所有订阅者完成，也可以不等待，直接返回。
   并行发布功能使用了timeout参数，可以设置等待超时时间，避免无限等待。
   并行发布功能使用了priority参数，可以设置订阅者优先级，优先级高的订阅者先执行。
   并行发布功能使用了filter_func参数，可以设置订阅者过滤函数，过滤掉不需要的订阅者。
   并行发布功能使用了subscriber_name参数，可以设置订阅者名称，用于记录订阅者名称。
   并行发布功能使用了total_calls参数，可以记录订阅者执行次数。
   并行发布功能使用了error_count参数，可以记录订阅者执行错误次数。

部分构建了显示模块的设计方案

- 11-28
完善了数据打包的逻辑。

设计了渲染模块的设计方案。

## 2025-12-1 ~ 2025-12-07

- 12-01

   设计了数据处理模块的DTO，在detectionDTO的基础上新增了状态标签字段。准备用于传输给显示模块使用。

   设计了打包模块的样板。

   内部缓存和打包需要考虑线程安全以及缓存逻辑。



- 12-02

   重新设计了打包器的结构和接收逻辑。

   外部事件订阅后，调用回调函数，组装统一的外部事件数据结构，然后打包模块内部主循环阻塞读取事件
   事件读取后导入半匹配结构字典，等待下一事件用于配对，并顺便检查去除超时部分。


- 12-03
   完成了打包模块的实现，但是现在一次只能产出一个设备的一帧数据。
   准备修改缓冲区，设置为带dict的双缓冲结构，对外的提取接口新增mxid的参数。



- 12-04
   修改了打包模块的缓冲区结构，修改了提取接口.

   内部队列改为按设备创建的缓冲队列，外部统一接收数据，然后组合渲染包导入队列。

   开放接口一次性获取两个设备的渲染包数据，使用旧帧缓冲的策略，允许帧率低的设备使用重复帧。

- 12-05
   修改了缓冲区结构，使用字典缓冲，key为设备ID，值为渲染包队列。
   自定义Queue，可以在队列满时自动丢弃。

   在打包模块中将Queue改为OverflowQueue，可以在队列满时自动丢弃。

   去除了内部锁的使用，优化了架构。


- 12-06

   优化了背压方案，准备设计背压组件。