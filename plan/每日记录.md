存放了每日的开发记录

## 2025-11-03

**验证器的实现**

验证器的实现应该先统一调用各个DTO字段内部的验证逻辑，然后再实现各个DTO之间的验证逻辑。所以第一步是重新梳理各个DTO的验证逻辑，并实现验证器的实现。

TODO：
- [ √ ] 重新梳理各个DTO的验证逻辑，并补全内部验证。
- [ √ ] 实现验证器的额外校验逻辑。
- [ √ ] 实现验证器的统一入口。


### 2025-11-04

完善了配置DTO内部的验证逻辑，现在可以对顶层DTO调用验证接口，快速进行DTO内部自检，下一步可以开始实现验证器的额外校验逻辑。
也就是对DTO之间的验证逻辑，比如角色绑定和设备元数据的一致性检查。

### 2025-11-05
完成了验证器的实现。



## 2025-11-05
**配置管理器的实现**

### 2025-11-06
基本完成了样板DTO工具的实现，为配置管理器创建默认配置和配置参数的硬编码管理提供了支持。

**注**：实现样板工具是因为直接管理JSON配置太过于困难，样板工具可以方便的创建默认配置和配置参数的硬编码管理。
后续开发CLI工具或者可视化管理工具后，再迁移重心到JSON配置。

下一步，继续完善配置管理器。



### 2025-11-07

**配置管理器已实现接口**

1. __init__(config_path=None, auto_create=True, eager_load=False, include_runtime_checks=False)
   初始化配置管理器并设置路径/内部状态，可选构造期加载。

2. load_config(validate=True, config_path=None, auto_create=None) -> bool
   从 JSON 读取为 `DeviceManagerConfigDTO`，可自动创建默认配置并做结构校验。

3. save_config() -> bool
   将当前“可运行配置”原子写盘并更新时间戳。

4. get_config() -> DeviceManagerConfigDTO
   获取当前“草稿配置”（未加载则抛错）。

5. get_runnable_config() -> DeviceManagerConfigDTO
   获取当前“可运行配置”（不存在则抛错）。

6. create_and_set_default_config() -> bool
   设备发现→创建默认配置→内部匹配，设置草稿=可运行配置并记录匹配结果。

7. promote_runnable_if_valid(include_runtime_checks=True, persist=False) -> DeviceManagerConfigDTO
   校验草稿通过后晋升为“可运行配置”，可选立即持久化。

8. restore_runnable_config() -> DeviceManagerConfigDTO
   将草稿回滚为最近一次“可运行配置”快照。

9. _match_config_internal(config, online_devices, ..., require_at_least_one_binding=True) -> (DeviceManagerConfigDTO, DeviceMatchResult)
   使用 `DeviceMatchManager` 执行匹配/自动绑定并导出新配置，可选做全量/运行态校验。

10. get_default_config() -> DeviceManagerConfigDTO
   创建并返回的默认配置（工厂方法）：根据设备列表创建未绑定的原生配置，后续需进行绑定


### 2025-11-08

**配置管理器新增已实现接口**

1. get_last_match_result() -> Optional[DeviceMatchResult]
   获取最近一次设备匹配的结果（只读）。

2. is_dirty() -> bool
   检查当前“草稿配置”是否领先于“可运行配置”。

3. has_runnable_config() -> bool
   检查是否存在“可运行配置”。

4. validate_config(include_runtime_checks=False) -> (bool, List[str])
   统一入口执行结构/跨字段校验，可选启用运行态校验。

5. get_oak_module_config() -> OAKModuleConfigDTO
   获取 OAK 模块配置（从“可运行配置”导出）。

6. get_data_processing_config() -> DataProcessingConfigDTO
   获取数据处理模块配置（从“可运行配置”导出）。

7. get_can_config() -> CANConfigDTO
   获取 CAN 模块配置（从“可运行配置”导出）。

8. get_display_config() -> DisplayConfigDTO
   获取显示模块配置（从“可运行配置”导出）。

9. get_system_config() -> SystemConfigDTO
   获取系统模块配置（从“可运行配置”导出）。


## 2025-11-09~2025-11-15

确认了事件模块的实现方案，并实现了事件模块的样板代码。
对各个模块开始增加日志处理功能。
完成了系统异常日志捕捉的钩子函数，线程日志异常捕捉的钩子函数。


## 2025-11-17~2025-11-23
- 11-17
   设备匹配器日志功能补全完毕。
   日志配置从零散配置改为统一入口处进行配置。

- 11-18
   日志统一配置函数`configure_logging`完成。
   `SystemConfigDTO`字段补充了timed rotating file handler的配置字段，支持按时间滚动和按大小滚动两种模式切换

- 11-19
   重新设计了配置管理器相关的日志。

   设计了数据采集模块的接口，并实现了样板代码，等待了解事件模块的具体使用方法后，再进行具体实现。

- 11-20
   事件总线更新了背压管理功能。

   确定了各个模块的主循环使用阻塞队列的形式获取数据，避免循环的空转造成性能开销。

   - 11-21
   事件总线更新了订阅者名称的记录功能。

   数据采集模块实现了采集管线的创建和设备启动。

   关闭了pipeline的NNnetwork输出，避免性能开销，减少传输带宽。

   正在重新设计detectiondto，减少冗余。

   正在设计数据采集模块的采集逻辑，现在在DTO组装阶段。


## 2025-11-24 ~ 2025-11-28

- 11-24

   对detection相关的DTO进行了重构，减少了冗余。具体：
   删除了尺寸信息，删除了detection_id，修改label为int类型。


   对collector模块内的DTO组装逻辑进行优化，减少性能开销。

- 11-25

   对collector中的变量进行修改，去除了self._pipeline变量，使用pipeline_manager.get_pipeline()获取pipeline对象,
   并在self.pipeline_manager中维护pipeline对象，减少复用。

   修复了_assemble_detection_data中的别名获取机制，使用device_binding.role.value获取别名。

   修改了_assemble_detection_data中的边界框坐标获取机制，使用原生坐标（因为本来就是float类型），减少了一步转换。

   去除_assemble_detection_data中多余的类型转换兜底。

   **注** 套用类似于int（）的类型转换作为兜底，会比直接使用多出一步函数调用的成本，在高频loop场景下最好避免。

   修改了PipelineManager中的enable_depth_output的获取机制，使用__resolve_enable_depth_output()获取，避免重复代码。

   为OAK数据流设置了锁结构，添加了安全退出的接口。

   修改了DTO中的enable_depth参数为enable_depth_output，更符合语境。

   实现了stop方法，添加了线程退出的安全检查和join逻辑，提升系统在停止流程时的稳定性。
   实现了start方法，添加了线程启动的安全检查和登记逻辑。
   新增worker_threads字典，维护每个设备的采集线程。

   下一步工作：
   实现显示模块的样板代码，并订阅事件总线，实现检测流+显示的最小闭环。然后做测试。


- 11-26

   修改了collector的running字典和_worker_threads字典的键，额外维护一个role-binding的字典用于查找。

   去除了role-binding字典，因为config内部自带了这个字典。

   修改collector的日志为参数化日志。

   修改数据阻塞获取为非阻塞获取，避免线程阻塞在获取数据上。

   修改帧同步机制，使用硬件序列号作为帧ID。

- 11-27
   事件总线更新了同步/异步模式，并行发布功能。
   并行发布功能使用了线程池，并行执行订阅者回调，提升多核利用率。
   并行发布功能使用了wait_all参数，可以等待所有订阅者完成，也可以不等待，直接返回。
   并行发布功能使用了timeout参数，可以设置等待超时时间，避免无限等待。
   并行发布功能使用了priority参数，可以设置订阅者优先级，优先级高的订阅者先执行。
   并行发布功能使用了filter_func参数，可以设置订阅者过滤函数，过滤掉不需要的订阅者。
   并行发布功能使用了subscriber_name参数，可以设置订阅者名称，用于记录订阅者名称。
   并行发布功能使用了total_calls参数，可以记录订阅者执行次数。
   并行发布功能使用了error_count参数，可以记录订阅者执行错误次数。

部分构建了显示模块的设计方案

- 11-28
完善了数据打包的逻辑。

设计了渲染模块的设计方案。

## 2025-12-1 ~ 2025-12-07

- 12-01

   设计了数据处理模块的DTO，在detectionDTO的基础上新增了状态标签字段。准备用于传输给显示模块使用。

   设计了打包模块的样板。

   内部缓存和打包需要考虑线程安全以及缓存逻辑。



- 12-02

   重新设计了打包器的结构和接收逻辑。

   外部事件订阅后，调用回调函数，组装统一的外部事件数据结构，然后打包模块内部主循环阻塞读取事件
   事件读取后导入半匹配结构字典，等待下一事件用于配对，并顺便检查去除超时部分。


- 12-03
   完成了打包模块的实现，但是现在一次只能产出一个设备的一帧数据。
   准备修改缓冲区，设置为带dict的双缓冲结构，对外的提取接口新增mxid的参数。



- 12-04
   修改了打包模块的缓冲区结构，修改了提取接口.

   内部队列改为按设备创建的缓冲队列，外部统一接收数据，然后组合渲染包导入队列。

   开放接口一次性获取两个设备的渲染包数据，使用旧帧缓冲的策略，允许帧率低的设备使用重复帧。

- 12-05
   修改了缓冲区结构，使用字典缓冲，key为设备ID，值为渲染包队列。
   自定义Queue，可以在队列满时自动丢弃。

   在打包模块中将Queue改为OverflowQueue，可以在队列满时自动丢弃。

   去除了内部锁的使用，优化了架构。


- 12-06

   优化了背压方案，准备设计背压组件。

## 2025-12-08 ~ 2025-12-14

- 12-08
   优化了背压模块的设计方案，借由事件总线来发布背压事件，使用依赖注入的方式来绑定模块的适配器。


- 12-10
   改为使用自注册的方式，给背压模块注册队列。

   背压模块完整设计：
   1、为了方便监控，实现了一个继承Queue的泛型数据结构，可以方便的获取统计信息
   2、为了统一统计数据的获取格式，实现了一个适配器，把统计数据的返回接口统一了。
   3、背压模块和适配器配合，可以方便的监控每个队列的状态信息，并及时通过事件总线发布背压信号。
   4、再实现一层注册DTO，用于返回规定格式的注册信息。
   5、最后一层适配，就是在各个模块内部新增外部接口，返回注册DTO。


- 12-11
   背压模块新增了连续命中次数的计数，用于判断是否需要强限流。
   背压模块新增了弱限流和强限流的区别，弱限流是两帧取一帧，强限流是三帧取一帧。

- 12-12 ~ 12-13
   整理旧版本代码：
   GUI/test*文件夹内是坐标变换参数调整组件，可使用GUI界面调整坐标变换参数到大致合适的值。

   香橙派的OAK项目文件夹下有单独的can通信模拟模块can_controller.py，可模拟下游控制器发送坐标获取指令并解读坐标数据。

   temp3.0文件夹内的dual_detection.py文件可启动检测流

   configs子文件夹内存放了配置信息，可修改此处的坐标变换参数。

   由于左右摄像头安装反了，现在的修正模块的修正方程已经不再适应，需要重新启动修正流。

   error文件夹内我新建了两个文件夹，分别是new_error_analysis和height_correction。分别存放高度修正分析文件和二维坐标误差分析文件。
   可用于生成高度修正方程和二维误差修正方程。


## 2025-12-15 ~ 2025-12-20

- 12-15 

   整理了新的左相机修正方程，修正精度达到30mm（x、y方向）


- 12-16  
   背压模块需要统一各个队列的情况，聚合分析后再决定是否发布事件。
   修改背压状态枚举和背压动作枚举为IntEnum，用于优先级排序。

   还需要设计如何比较各个队列的背压状态和背压动作，用于聚合分析后再决定是否发布事件。

- 12-17 ~ 12-18
   背压模块新增了单例实例和锁，用于保证背压监控器只被创建一次，线程安全。
   修改了背压状态和背压动作的枚举，用于优先级排序。
   补充了背压聚合逻辑，基本完成背压模块的实现。

   下一步，在数据源模块补充背压相关的订阅，补充背压状态机逻辑，实现背压逻辑。


- 12-20

   补全了背压模块的实现。
   在数据源模块补全了背压的订阅，背压动作的逻辑。
   下一步，开发数据处理模块。


## 2025-12-21 ~ 2025-12-28

- 12-22
   先更新一下坐标变换组件的语义，使其符合坐标系移动的直觉（输入的数值为坐标系的变换量）。

   数据处理模块决定使用单一线程，外部带device_id的数据DTO统一入一个队列，内部主循环阻塞获取，然后根据device_id进行分流处理。
   
   坐标变换模块根据传入的配置参数，内部维护两组坐标变换参数，主要方法（坐标变换）
   根据传入的DeviceDetectionDataDTO数据自动选择坐标变换参数来处理数据。

   滤波模块也一样，内部根据device_id维护多份状态，然后内部统一一个方法来处理数据。

- 12-23
   开始实现坐标变换模块的内容，测试了纯Python和numpy的计算性能差距。


- 12-24

   确认开发的滤波模块包括匹配功能，滤波功能。先开发基础的滤波模块。
   

- 12-25

   继续开发滤波模块。实现了基于ioU的最近邻匹配算法。


- 12-26
   完善了坐标变换模块的核心方法get_trans_detection和get_trans_batch。

   下一步，开发filtermanager模块，实现滤波器管理器。负责整个数据处理模块的滤波器功能。

   filtermanager需要额外开发一个滤波器池才行，内部包括多个滤波器和ioU信息，配合tracker算法实现对检测结果的追踪滤波。
   

- 12-27
   明确了filterpool的职责，确定filtermanager为轻量级路由。


## 2025-12-28 ~ 2025-12-31


- 12-28 ~ 12-30

   寻找解决检测数量和滤波器数据不匹配的问题


- 12-30

   决定迭代ioUtracker为匈牙利算法，彻底解决匹配的问题。

   完成匈牙利算法的实现。

   下一步，开发filterpool模块，实现滤波器池。

   确定先滤波再坐标变换的逻辑，减少一次detectionDTO的封装和解包。


- 12-31
   修改坐标变换模块的输入输出，改为传入list[np.ndarray]，输出list[np.ndarray]。
   修改滤波器实例的输入，内部使用元组存储坐标数据。
   预计会减少一步封装，一步解包。


 
## 2026-01-04 ~ 2026-01-10

- 1-3 ~ 1-4
   修改了filterpool的输入输出，改为传入坐标矩阵、bbox矩阵、置信度列表。
   需要考虑如何设计数据处理模块的输出，以此来确定filterpool的输出。

   修改了模块间DTO契约的基类实现，去除了不必要的序列化能力，以及部分init字段。仅保留不可变特性。

   修改了坐标变换的矩阵元素类型为np.float32，避免内部提升为float 64带来的性能开销。


- 1-5 
   审查补全filterpool的实现


- 1-6

   设计修改
   1. filterpool应该输出的坐标变换矩阵和对应的bbox矩阵应该恢复到原来的顺序，
   不然则只能考虑内部封装成DetectionDTO的列表，然后输出列表。
   2. 滤波器实例应该直接输出坐标元组，因为已经决定把DeviceProcessedDataDTO设计为输出坐标的np.ndarray矩阵了。
   3. 我打算在数据处理模块这一层就让部分数据列表化和向量化了，方便后续拆分处理。
   所以filtermanager模块拿到的数据应该是坐标变换矩阵，bbox矩阵，置信度列表，label列表。
   并且filtermanager的主方法(循环的)应该多出一个参数device_id,用于数据分流。

- 1-7 

   重新完成了滤波器的计算设计，使用了计算更快的公式。



- 1-8 
   完成了对滤波器类的修改，滑动评价滤波器使用递推公式进行状态更新，减少了不必要的索引。
   下一步，对filterpool进行输入输出的修改，使其符合最小封装的设计。

   

- 1-9
   完成了对filterpool的修改，现在可以高效对坐标矩阵进行滤波，并按原顺序返回。

   下一步，开发filtermanager模块，实现滤波器管理器。负责整个数据处理模块的滤波器功能。

   要求：实现轻量路由功能，滤波器池管理功能。可能存在的数据组装需求。

- 1-10 
   完成了filtermanager的开发。


## 2026-01-12 ~ 2026-01-17

- 01-12

   完成了data_processor的开发。


- 1-13
   完成了data_processor的背压集成


- 1-14
   补全了datas_processor的集成测试


- 1-15

   [ √ ] collector的帧同步设计需要重新修改一下，不能使用硬件帧同步，得自己维护才行。

   [  ] 继续完成决策模块的设计和实现。


   检查打包模块的打包对齐逻辑


- 1-16

   修改了决策模块的设计

   确定了CAN模块使用同步接口，绕过事件总线来获得待抓取物的坐标

   确定了决策门口的基本接口和接口职责。

-1-17

   明确了配置管理器需要实现一个调试方法（在指定路径生成一个默认配置文件）

## 2026-01-19 ~ 2026-01-24

- 1-19
   完善实现决策模块

- 1-20
   完成了决策模块的实现

   下一步，从collector开始修复检测数据的空数据传递的问题，要求每一个模块都可以接受空的数据帧并创建对应的格式传递到下游

- 1-21
   完成了渲染模块，完成了显示模块的MVP
   确定了打包模块作为显示模块下的子模块，并决定不进行事件发布，而是采用线程安全的接口来提供渲染包给渲染模块。

   决定给配置管理器提供一个接口，输出设备的mxid列表。

- 1-22
   确定了CAN模块的设计，明确使用异步回调方案代替原本的线程监听方案，降低CPU的开销。
   CAN模块不需要再单独占据一个线程进行监听，把这个任务交由python-can库的异步监听来做。


- 1-23
   基本完成了CAN模块的构建，后续准备对上游模块进行实际测试。然后完善完整的显示模块。





## 2026-01-26 ~ 2026-01-31

- 1-26
   
   完成了对显示模块的实现，并明确是单窗口多设备显示，按照旧实现的形式。

   准备开始开发原设计的可用Tools，并开始进行冒泡测试。

   成功完成默认配置生成工具，下一步，修改元数据的导出问题，尝试实现JSON配置转YAML的逻辑，使得配置更清晰，并支持注释。


- 1-27
   修复了元数据的导出问题，修复了坐标变换参数的修改时间的问题，明确通过人工修改参数字符串来记录参数修改时间。

   明确开发YAML配置转换器，使得配置管理器可以加载YAML配置，YAML配置可加注释，更方便阅读。

   开发了YAML配置转换的工具，并集成到配置管理器中。


- 1-28

   编写了显示模块的集成测试

   编写了CAN模块的Linux下的集成测试和实机测试。

   编写了部分实机测试，完成了显示模块的测试


- 1-29

   设备发现器启动后，会占据OAK设备连接，所以需要在发现完毕后设计一个延时，保证设备释放，才能创建pipeline。

   需要设计一个停止方案，保证上游---下游---总线的停止顺序。

- 1-30

   设计系统管理器，现在在信号处理器部分。


## 2026-2-2 ~ 2026-2-7

- 2-2
   重新设计了systemmanager


- 2-3
   检查修改各个模块的stop方法，并修改使其符合stop职责。

   设计绑定工具，完善配置创建-->绑定的流程。完成后下一步是开发主流程脚本。


   基于systemmanager，创建主程序入口tools，验证完整的检测流。

   修改CAN的警报定时器逻辑，改为单线程定时器。

   创建CAN基类，设计虚拟CAN，用于Windows端测试。