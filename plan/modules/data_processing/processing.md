# 数据处理模块实现计划

接收DeviceDetectionDataDTO数据，并对其中的detections数据进行处理。
基础功能包括坐标变换和滤波。


## 坐标变换

基于机械臂模型，生成了固定变换矩阵的坐标变换矩阵，可用于向量化的快速坐标变换。内部坐标变换逻辑以device_id进行分类。


## 滤波
包括滤波器实现和匹配算法部分。

### 滤波
实现一个滤波器，可以内部保存状态信息，根据传入的坐标信号进行滤波，并输出新的滤波值。
现在实现的是滑动平均滤波，使用递推公式的版本，速度更快。

### 匹配算法

实现一个匹配方法，根据先前的检测结果（坐标，ioU等信息），区分当前检测结果和滤波器的关系，实现对检测实物的追踪滤波。

**第一版**：
实现基于ioU的匹配方法，根据事先保存的bbox信息，计算ioU矩阵，可获取当前检测结果和前一帧检测结果的匹配索引字典。



思路：

1. 滤波器新增一个内部计数器，用来记录未更新计数，如果超过一定阈值，则认为该检测结果已消失，需要删除。
在匹配过程中，根据匹配计算出的trackid字典（或者什么数据结构），遍历当前的滤波器池，如果有对应的tracker，则调用input方法，输入新的检测结果，并获取新的预测结果。

**重点**：如何更新计数器？可以在预测方法predict中对计数器进行自增，而在input方法中对计数器进行重置。

2. 按设备id和标签来区分滤波器池，一个设备一个标签一个滤波器池。

3. 对于滤波器池，持有一个槽位复用的滤波器列表（暂定是列表），用于复用滤波器，减少创建销毁的开销。
同时，持有一个bbox矩阵，用于track匹配计算。

4. 匹配算法实现：

 - 按照设备id和标签提取不同的detectionDTO列表。
 - 提取对应列表的bbox矩阵，然后和对应滤波器池的bbox矩阵进行匹配计算ioU，算法使用IoUMatcher算法。
 - 根据匹配索引，将对应的坐标数据通过input方法输入对应的滤波器中。
 - 对未调用input方法的滤波器调用一次predict方法，更新其内部未匹配帧数计数器的值，但不使用其结果。
 - 如果有未匹配的检测结果，则导入到无状态的滤波器中，也是调用input方法。


5. 滤波器池类的设计
    滤波器池作为滤波器功能的核心部分，应该有下面的功能或者设计
 - 持有多个独立的滤波器。
 - 内部维护一个私有方法获取bbox矩阵
 - 持有有效滤波器索引（numpy布尔数组），作为掩码形式使用。




### filterpool职责描述

#### 滤波器生命周期管理

1. 维护一组可复用的滤波器槽位（预分配），用于复用滤波器。
2. 维护一个numpy掩码，区分当前有效的滤波器和无效的滤波器。
3. 滤波器内部自带自身的状态管理，长时间无有效数据输入，则自动清空自身的状态。
4. 根据检测结果的数量和当前活跃滤波器的数据决定分配方法。


#### 帧间匹配与状态更新策略

1. 传入的detection列表会调用tracker算法，基于当前帧的bbox和上一帧的bbox计算ioU矩阵，获得匹配索引。
2. 具体而言，是将提取到的新一帧的bbox和提取到的上一帧的bbox传入ioUmatcher算法，获得匹配索引。
3. 根据索引分配detection到对应的滤波器中。
4. 分配完成，如果仍有未匹配的detection，则分配到无状态的滤波器中。
5. 得到分配的滤波器调用input方法，同时获得其输出。
6. 未获得detection分配的的滤波器，调用一次predict方法，更新其内部未匹配帧数计数器的值，但不使用其结果。
7. 按顺序组装有效滤波器的输出，返回给上层。
   

#### 输入输出规定

1. 顶层路由根据deviceid和label拆分detectionDTO列表。
2. 拆分后的detectionDTO列表传入到不同的filterpool，进行帧间匹配和状态更新。


#### 关键设计特点

##### 槽位复用策略
- 预分配固定数量槽位，避免频繁内存分配
- 失效滤波器释放后可被新目标复用
- 使用 `active_mask` 高效管理活跃状态（O(1) 修改）

##### 历史轨迹管理
- 不维护完整的目标运动历史
- 仅保存上一帧状态（通过滤波器内部的 `_last_bbox`）
- `bbox` 矩阵按需临时提取，用完即丢弃

##### 自管理生命周期
- 滤波器通过内部计数器自动判断失效
- 池只需调用 `predict()` 和 `input()`，无需手动维护年龄
- 可通过 `is_valid()` 方法查询滤波器状态