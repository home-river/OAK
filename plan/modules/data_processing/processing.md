# 数据处理模块实现计划

接收DeviceDetectionDataDTO数据，并对其中的detections数据进行处理。
基础功能包括坐标变换和滤波。

处理顺序（语义优先）：先进行坐标变换（统一到世界/XYZ坐标系），再进行滤波/追踪（filterpool 内部完成匹配与状态更新）。


## 坐标变换

基于机械臂模型，生成了固定变换矩阵的坐标变换矩阵，可用于向量化的快速坐标变换。内部坐标变换逻辑以device_id进行分类。

坐标变换在滤波/追踪之前执行：对输入的 detection 坐标结果进行批量变换。

### 模块的输入输出规定

规定输入是mxid（用于区分设备）和list[DetectionDTO]。

输出是np.ndarray矩阵，其形状为(n,3)。

## 滤波
包括滤波器实现和匹配算法部分。

### 滤波
实现一个滤波器，可以内部保存状态信息，根据传入的坐标信号进行滤波，并输出新的滤波值。
现在实现的是滑动平均滤波，使用递推公式的版本，速度更快。


### 模块输入输出规定

#### 滤波器实例
滤波器实例接收坐标变换传递来的坐标和bbox信息，内部滤波后输出新的滤波值（坐标）。

### 匹配算法

实现一个匹配方法，根据先前的检测结果（坐标，ioU等信息），区分当前检测结果和滤波器的关系，实现对检测实物的追踪滤波。

**第一版**：
实现基于ioU的匹配方法，根据事先保存的bbox信息，计算ioU矩阵，可获取当前检测结果和前一帧检测结果的匹配索引字典。



思路：

1. 滤波器新增一个内部计数器，用来记录未更新计数，如果超过一定阈值，则认为该检测结果已消失，
需要删除,此时清空滤波器内部状态，然后返回False。
在匹配过程中，根据匹配计算出的trackid字典（或者什么数据结构），遍历当前的滤波器池，如果有对应的tracker，
则调用input方法，输入新的检测结果，并获取新的预测结果。

**重点**：如何更新计数器？可以在丢失一帧的方法miss（）中对计数器进行自增，而在input方法中对计数器进行重置。

2. 按设备id和标签来区分滤波器池，一个设备一个标签一个滤波器池。

3. 对于滤波器池，持有一个槽位复用的滤波器列表（暂定是列表），用于复用滤波器，减少创建销毁的开销。
同时，持有一个bbox矩阵，用于track匹配计算。

4. 匹配算法实现：

 - 按照设备id和标签提取不同的detectionDTO列表。
 - 提取对应列表的bbox矩阵，然后和对应滤波器池的bbox矩阵进行匹配计算ioU，算法使用IoUMatcher算法。
 - 根据匹配索引，将对应的坐标数据通过input方法输入对应的滤波器中。
 - 对未调用input方法的滤波器调用一次predict方法，更新其内部未匹配帧数计数器的值，但不使用其结果。
 - 如果有未匹配的检测结果，则导入到无状态的滤波器中，也是调用input方法。

5. 滤波器池类的设计
    滤波器池作为滤波器功能的核心部分，应该有下面的功能或者设计
 - 持有多个独立的滤波器。
 - 内部维护一个私有方法获取bbox矩阵
 - 持有有效滤波器索引（numpy布尔数组），作为掩码形式使用。




### filterpool职责描述

#### 滤波器生命周期管理

1. 维护一组可复用的滤波器槽位（预分配），用于复用滤波器。
2. 维护一个numpy掩码，区分当前有效的滤波器和无效的滤波器。
3. 滤波器内部自带自身的状态管理，长时间无有效数据输入，则自动清空自身的状态。
4. 根据检测结果的数量和当前活跃滤波器的数据决定分配方法。


#### 帧间匹配与状态更新策略

1. 传入的detection列表会调用tracker算法，基于当前帧的bbox和上一帧的bbox计算ioU矩阵，获得匹配索引。
2. 具体而言，是将提取到的新一帧的bbox和提取到的上一帧的bbox传入ioUmatcher算法，获得匹配索引。
3. 根据索引分配detection到对应的滤波器中。
4. 分配完成，如果仍有未匹配的detection，则分配到无状态的滤波器中。
5. 得到分配的滤波器调用input方法，同时获得其输出。
6. 未获得detection分配的的滤波器，调用一次miss方法，更新其内部未匹配帧数计数器的值，并顺便根据返回的状态值更新掩码。
7. 按顺序组装有效滤波器的输出，返回给上层。
   

#### 输入输出规定

1. 顶层路由根据deviceid提取detectionDTO列表，并先进入坐标变换模块。
2. 坐标变换后的detectionDTO列表再根据deviceid和label拆分。
3. 拆分后的detectionDTO列表传入到不同的filterpool，进行帧间匹配和状态更新并输出。

#### 关键设计特点

##### 槽位复用策略
- 预分配固定数量槽位，避免频繁内存分配
- 失效滤波器清空状态后可被新目标复用
- 使用 `active_mask` 高效管理活跃状态（O(1) 修改）

##### 历史轨迹管理
- 不维护完整的目标运动历史
- 仅保存上一帧状态（通过滤波器内部的 `_last_bbox`）
- `bbox` 矩阵按需临时提取，用完即丢弃

##### 自管理生命周期
- 滤波器通过内部计数器自动判断失效
- 池只需调用 `miss()` 和 `input()`，无需手动维护年龄,miss方法还能返回滤波器有效状态。
- 可通过 `is_valid()` 方法查询滤波器状态



## 滤波器管理器模块职责描述

管理多个滤波器池实例，滤波器池实例根据device_id和label来区分。
接受上游坐标变换模块处理后的坐标矩阵和bbox矩阵以及confidence列表、labels列表。
然后根据device_id和label来区分，对坐标矩阵和bbox矩阵和confidence列表进行拆分，然后传入到对应的滤波器池进行处理。





## 顶层数据处理模块职责

主要工作流：
1. 从输入队列中拿到上游发布的DeviceDetectionDataDTO，然后取出device_id和List[DetectionDTO]。
2. 将device_id和List[DetectionDTO]传入坐标变换模块，获取转换后的坐标矩阵，
该矩阵中的坐标顺序和List[DetectionDTO]中的坐标顺序一致。
3. 从List[DetectionDTO]提取出bbox矩阵和confidence列表，以及label列表。
4. 根据label获得不同label的数据索引，根据索引可以进一步拆分（或者分辨）坐标矩阵、bbox矩阵、
confidence列表，并分组。
5. 根据索引device_id和label,可以把每一组数据传递到对应的滤波器池中进行处理。
6. 把滤波器池处理后的坐标拿出来，和其他数据一起按原顺序组装，最后封装成DeviceDetectionDataDTO。