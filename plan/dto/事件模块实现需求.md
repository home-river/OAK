## 模式2（推送+背压）实现逻辑总结

### **核心思想**

数据源模块默认按固定速率主动推送数据，当下游（显示模块）处理不过来时，通过发送背压信号通知数据源模块暂停推送，待下游恢复后再通知恢复推送。

---

### **角色分工**

**数据源模块（生产者）**：

* 持有一个布尔标志 `enabled`（初始为 True）
* 运行一个推送循环，按固定间隔（如 1/15秒）从摄像头队列拉取数据
* 每次循环检查 `enabled` 标志，若为 True 则发布 `RAW_FRAME_DATA` 事件
* 订阅 `BACKPRESSURE_SIGNAL` 事件，根据信号内容切换 `enabled` 标志

**显示模块（消费者+监控者）**：

* 维护一个 `pending_count` 计数器，记录待处理的帧数
* 维护一个 `backpressure_active` 标志，记录当前是否已触发背压
* 收到原始数据时，`pending_count++`，并检查是否达到高水位（如 ≥80%）
* 达到高水位且未触发背压时，发布 `BACKPRESSURE_SIGNAL` 事件（action='PAUSE'）
* 处理完一帧后，`pending_count--`，并检查是否降到低水位（如 ≤20%）
* 降到低水位且已触发背压时，发布 `BACKPRESSURE_SIGNAL` 事件（action='RESUME'）

---

### **工作流程**

**正常状态**：

1. 数据源模块每 66ms（15fps）从摄像头队列拉取一帧数据
2. 发布 `RAW_FRAME_DATA` 事件
3. 显示模块和数据处理模块订阅该事件并处理
4. 显示模块的 `pending_count` 在低水位范围内波动
5. 无背压信号产生

**过载状态**：

1. 下游处理变慢，显示模块的 `pending_count` 累积到 4（假设阈值是 5，高水位 80%）
2. 显示模块发布 `BACKPRESSURE_SIGNAL`（action='PAUSE'）
3. 数据源模块收到信号，设置 `enabled = False`
4. 数据源模块的推送循环继续运行，但不再发布数据事件（空转）
5. 显示模块继续消费已有的待处理帧

**恢复状态**：

1. 显示模块处理完积压的帧，`pending_count` 降到 1（低水位 20%）
2. 显示模块发布 `BACKPRESSURE_SIGNAL`（action='RESUME'）
3. 数据源模块收到信号，设置 `enabled = True`
4. 数据源模块恢复正常推送

---

### **关键设计点**

1. **开关式控制**：背压是二值的（暂停/恢复），不是连续调速
2. **水位阈值**：使用高低水位避免频繁抖动（高水位触发暂停，低水位触发恢复）
3. **事件稀疏**：背压信号仅在状态切换时发送，不是每帧都发
4. **单向依赖**：只有显示模块监控自身状态并发出背压，数据源模块被动响应
5. **推送保留**：数据源模块的推送循环始终运行，只是通过标志控制是否发布事件
6. **摄像头队列自然丢旧**：暂停期间摄像头队列继续积累新数据并自动丢弃旧数据，恢复后处理的是最新数据

---

### **性能特点**

* **事件数量少**：正常运行只有数据事件（15次/秒），背压切换时才额外产生2次信号
* **无阻塞等待**：数据源模块用简单的布尔检查，无锁、无信号量
* **响应及时**：显示模块每处理一帧就检查水位，能快速触发/解除背压
* **实现简单**：总共不到50行核心代码，易于理解和维护

---

### **适用场景**

* 下游偶尔过载，但大多数时候能跟上
* 不需要精确控制在途帧数，允许短暂的积压
* 追求极简实现和低CPU开销
* 摄像头数据可以丢弃（因为暂停期间摄像头队列会丢旧数据）
